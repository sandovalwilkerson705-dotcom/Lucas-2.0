(async () => {
let canalId = ["120363266665814365@newsletter"];  
let canalNombre = ["üëæ AZURA ULTRA 2.0 BOT üëæ"]
  function setupConnection(conn) {
  conn.sendMessage2 = async (chat, content, m, options = {}) => {
    const firstChannel = { 
      id: canalId[0], 
      nombre: canalNombre[0] 
    };
    if (content.sticker) {
      return conn.sendMessage(chat, { 
        sticker: content.sticker 
      }, { 
        quoted: m,
        ...options 
      });
    }
    const messageOptions = {
      ...content,
      mentions: content.mentions || options.mentions || [],
      contextInfo: {
        ...(content.contextInfo || {}),
        forwardedNewsletterMessageInfo: {
          newsletterJid: firstChannel.id,
          serverMessageId: '',
          newsletterName: firstChannel.nombre
        },
        forwardingScore: 9999999,
        isForwarded: true,
        mentionedJid: content.mentions || options.mentions || []
      }
    };

    return conn.sendMessage(chat, messageOptions, {
      quoted: m,
      ephemeralExpiration: 86400000,
      disappearingMessagesInChat: 86400000,
      ...options
    });
  };
}
//nsfw 
async function getPrompt() {
  try {
    const res = await fetch('https://raw.githubusercontent.com/elrebelde21/LoliBot-MD/main/src/text-chatgpt.txt');
    return await res.text();
  } catch {
    return 'Eres un asistente inteligente';
  }
}

function cleanResponse(text) {
  if (!text) return '';
  return text
    .replace(/Maaf, terjadi kesalahan saat memproses permintaan Anda/g, '')
    .replace(/Generated by BLACKBOX\.AI.*?https:\/\/www\.blackbox\.ai/g, '')
    .replace(/and for API requests replace https:\/\/www\.blackbox\.ai with https:\/\/api\.blackbox\.ai/g, '')
    .trim();
}

async function luminaiQuery(q, user, prompt) {
  const { data } = await axios.post('https://luminai.my.id', {
    content: q,
    user: user,
    prompt: prompt,
    webSearchMode: true
  });
  return data.result;
}

async function perplexityQuery(q, prompt) {
  const { data } = await axios.get('https://api.perplexity.ai/chat', {
    params: {
      query: encodeURIComponent(q),
      context: encodeURIComponent(prompt)
    }
  });
  return data.response;
}
  //lumi
    const axios = require("axios");
    const fetch = require("node-fetch");
    const { cargarSubBots } = require("./indexsubbots");
    await cargarSubBots()
    const { default: makeWASocket, useMultiFileAuthState, fetchLatestBaileysVersion, makeCacheableSignalKeyStore } = require("@whiskeysockets/baileys");
    const chalk = require("chalk");
    const yargs = require('yargs/yargs')
    const { tmpdir } = require('os')
    const { join } = require('path')
    const figlet = require("figlet");
    const fs = require("fs");
    const { readdirSync, statSync, unlinkSync } = require('fs')
    const readline = require("readline");
    const pino = require("pino");
    const { isOwner, getPrefix, allowedPrefixes } = require("./config");
    const { handleCommand } = require("./main"); 
    // Carga de credenciales y estado de autenticaci√≥n
    const { state, saveCreds } = await useMultiFileAuthState("./sessions");
  const { downloadContentFromMessage } = require('@whiskeysockets/baileys');
  //lista
function isAllowedUser(sender) {
  const listaFile = "./lista.json";
  if (!fs.existsSync(listaFile)) return false;
  const lista = JSON.parse(fs.readFileSync(listaFile, "utf-8"));
  // Extrae solo los d√≠gitos del n√∫mero para comparar
  const num = sender.replace(/\D/g, "");
  return lista.includes(num);
}
    
    //privado y admins

const path = "./activos.json";

// üìÇ Cargar configuraci√≥n de modos desde el archivo JSON
function cargarModos() {
    if (!fs.existsSync(path)) {
        fs.writeFileSync(path, JSON.stringify({ modoPrivado: false, modoAdmins: {} }, null, 2));
    }
    return JSON.parse(fs.readFileSync(path, "utf-8"));
}

// üìÇ Guardar configuraci√≥n de modos en el archivo JSON
function guardarModos(data) {
    fs.writeFileSync(path, JSON.stringify(data, null, 2));
}

let modos = cargarModos();
    
    // Configuraci√≥n de consola
    console.log(chalk.cyan(figlet.textSync("Azura Ultra Bot", { font: "Standard" })));    
    console.log(chalk.green("\n‚úÖ Iniciando conexi√≥n...\n"));
    
    // ‚úÖ Mostrar opciones de conexi√≥n bien presentadas
    console.log(chalk.yellow("üì° ¬øC√≥mo deseas conectarte?\n"));
    console.log(chalk.green("  [1] ") + chalk.white("üì∑ Escanear c√≥digo QR"));
    console.log(chalk.green("  [2] ") + chalk.white("üîë Ingresar c√≥digo de 8 d√≠gitos\n"));

    // Manejo de entrada de usuario
    const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
    const question = (text) => new Promise((resolve) => rl.question(text, resolve));

    let method = "1"; // Por defecto: C√≥digo QR
    if (!fs.existsSync("./sessions/creds.json")) {
        method = await question(chalk.magenta("üìû Ingresa tu n√∫mero (Ej: 5491168XXXX) "));

        if (!["1", "2"].includes(method)) {
            console.log(chalk.red("\n‚ùå Opci√≥n inv√°lida. Reinicia el bot y elige 1 o 2."));
            process.exit(1);
        }
    }

    async function startBot() {
        try {
            let { version } = await fetchLatestBaileysVersion();
            const socketSettings = {
                printQRInTerminal: method === "1",
                logger: pino({ level: "silent" }),
                auth: { creds: state.creds, keys: makeCacheableSignalKeyStore(state.keys, pino({ level: "silent" })) },
                browser: method === "1" ? ["AzuraBot", "Safari", "1.0.0"] : ["Ubuntu", "Chrome", "20.0.04"],
            };

            const sock = makeWASocket(socketSettings);
setupConnection(sock)
            // Si la sesi√≥n no existe y se usa el c√≥digo de 8 d√≠gitos
            if (!fs.existsSync("./sessions/creds.json") && method === "2") {
                let phoneNumber = await question("üòéFino vamos ayaüòé: ");
                phoneNumber = phoneNumber.replace(/\D/g, "");
                setTimeout(async () => {
                    let code = await sock.requestPairingCode(phoneNumber);
                    console.log(chalk.magenta("üîë C√≥digo de vinculaci√≥n: ") + chalk.yellow(code.match(/.{1,4}/g).join("-")));
                }, 2000);
            }

//_________________

global.opts = new Object(yargs(process.argv.slice(2)).exitProcess(false).parse())

//tmp
if (!opts['test']) {
  setInterval(async () => {
  //  if (global.db.data) await global.db.write().catch(console.error)
    if (opts['autocleartmp']) try {
      clearTmp()

    } catch (e) { console.error(e) }
  }, 60 * 1000)
}

if (opts['server']) (await import('./server.js')).default(global.conn, PORT)

/* Clear */
async function clearTmp() {
  const tmp = [tmpdir(), join(__dirname, './tmp')]
  const filename = []
  tmp.forEach(dirname => readdirSync(dirname).forEach(file => filename.push(join(dirname, file))))

  //---
  return filename.map(file => {
    const stats = statSync(file)
    if (stats.isFile() && (Date.now() - stats.mtimeMs >= 1000 * 60 * 1)) return unlinkSync(file) // 1 minuto
    return false
  })
}

setInterval(async () => {
  await clearTmp()
  console.log(chalk.cyanBright(`‚ï≠‚îÅ‚îÄ‚îÅ‚îÄ‚îÅ‚îÄ‚â™üîÜ‚â´‚îÄ‚îÅ‚îÄ‚îÅ‚îÄ‚îÅ‚ïÆ\n‚îÇSE LIMPIO LA CARPETA TMP CORRECTAMENTE\n‚ï∞‚îÅ‚îÄ‚îÅ‚îÄ‚îÅ‚îÄ‚â™üîÜ‚â´‚îÄ‚îÅ‚îÄ‚îÅ‚îÄ‚îÅ‚ïØ`))
}, 1000 * 60 * 60); // ‚Üê 1 hora en milisegundos

//sessions/jadibts
            // Funci√≥n para verificar si un usuario es administrador en un grupo
            async function isAdmin(sock, chatId, sender) {
                try {
                    const groupMetadata = await sock.groupMetadata(chatId);
                    const admins = groupMetadata.participants
                        .filter(p => p.admin)
                        .map(p => p.id);
                    return admins.includes(sender) || isOwner(sender);
                } catch (error) {
                    console.error("Error verificando administrador:", error);
                    return false;
                }
            }

// Ruta de los archivos a limpiar
const archivosAntidelete = [
  './antidelete.json',
  './antideletepri.json',
  './gruposu.json',
  './prisu.json'
];

function limpiarAntidelete() {
  for (const archivo of archivosAntidelete) {
    if (fs.existsSync(archivo)) {
      fs.writeFileSync(archivo, JSON.stringify({}, null, 2));
      console.log(`üßπ Archivo limpiado: ${archivo}`);
    }
  }
}

// Ejecutar limpieza cada 30 minutos
setInterval(limpiarAntidelete, 30 * 60 * 1000); // 30 min

// Ejecutar una vez al inicio
limpiarAntidelete();
//cada 30 minutos antidelete          
          

          // Funci√≥n para revisar y actualizar grupos cada 5 segundos
setInterval(async () => {
  try {
    const ahora = Date.now();

    // === REVISAR CIERRE AUTOM√ÅTICO ===
    const tiempoCerrarPath = path.resolve("./tiempo1.json");
    if (fs.existsSync(tiempoCerrarPath)) {
      const tiempoCerrar = JSON.parse(fs.readFileSync(tiempoCerrarPath, "utf-8"));

      for (const groupId of Object.keys(tiempoCerrar)) {
        const tiempoLimite = tiempoCerrar[groupId];
        if (ahora >= tiempoLimite) {
          console.log(`‚è∞ Se cumpli√≥ el tiempo para CERRAR el grupo: ${groupId}`);

          try {
            await sock.groupSettingUpdate(groupId, "announcement"); // Cerrar grupo
            await sock.sendMessage(groupId, {
              text: "üîí El grupo ha sido cerrado autom√°ticamente. Solo admins pueden escribir."
            });
          } catch (error) {
            console.error(`‚ùå Error cerrando grupo ${groupId}:`, error);
          }

          delete tiempoCerrar[groupId];
          fs.writeFileSync(tiempoCerrarPath, JSON.stringify(tiempoCerrar, null, 2));
        }
      }
    }
//limpieza
    
    // === REVISAR APERTURA AUTOM√ÅTICA ===
    const tiempoAbrirPath = path.resolve("./tiempo2.json");
    if (fs.existsSync(tiempoAbrirPath)) {
      const tiempoAbrir = JSON.parse(fs.readFileSync(tiempoAbrirPath, "utf-8"));

      for (const groupId of Object.keys(tiempoAbrir)) {
        const tiempoLimite = tiempoAbrir[groupId];
        if (ahora >= tiempoLimite) {
          console.log(`‚è∞ Se cumpli√≥ el tiempo para ABRIR el grupo: ${groupId}`);

          try {
            await sock.groupSettingUpdate(groupId, "not_announcement"); // Abrir grupo
            await sock.sendMessage(groupId, {
              text: "üîì El grupo ha sido abierto autom√°ticamente. ¬°Todos pueden escribir!"
            });
          } catch (error) {
            console.error(`‚ùå Error abriendo grupo ${groupId}:`, error);
          }

          delete tiempoAbrir[groupId];
          fs.writeFileSync(tiempoAbrirPath, JSON.stringify(tiempoAbrir, null, 2));
        }
      }
    }

  } catch (error) {
    console.error("‚ùå Error en la revisi√≥n autom√°tica de grupos:", error);
  }
}, 5000); // Revisa cada 5 segundos
//ok de abria onkkkkkk
          
// Listener para detectar cambios en los participantes de un grupo (bienvenida y despedida)
sock.ev.on("group-participants.update", async (update) => {
  try {
    // Solo operar en grupos
    if (!update.id.endsWith("@g.us")) return;

    const fs = require("fs");
    const activosPath = "./activos.json";
    let activos = {};
    if (fs.existsSync(activosPath)) {
      activos = JSON.parse(fs.readFileSync(activosPath, "utf-8"));
    }

    // ***************** L√ìGICA ANTIARABE *****************
    // Si la funci√≥n antiarabe est√° activada en este grupo...
    if (activos.antiarabe && activos.antiarabe[update.id]) {
      // Lista de prefijos prohibidos (sin el signo +)
      const disallowedPrefixes = [
  "20",   // Egipto üá™üá¨
  "212",  // Marruecos üá≤üá¶
  "213",  // Argelia üá©üáø
  "216",  // T√∫nez üáπüá≥
  "218",  // Libia üá±üáæ
  "222",  // Mauritania üá≤üá∑
  "224",  // Guinea (algunos bots √°rabes)
  "249",  // Sud√°n üá∏üá©
  "252",  // Somalia üá∏üá¥
  "253",  // Yibuti üá©üáØ
  "269",  // Comoras üá∞üá≤
  "961",  // L√≠bano üá±üáß
  "962",  // Jordania üáØüá¥
  "963",  // Siria üá∏üáæ
  "964",  // Irak üáÆüá∂
  "965",  // Kuwait üá∞üáº
  "966",  // Arabia Saudita üá∏üá¶
  "967",  // Yemen üáæüá™
  "968",  // Om√°n üá¥üá≤
  "970",  // Palestina üáµüá∏
  "971",  // Emiratos √Årabes Unidos üá¶üá™
  "972",  // Israel (√°rabes usan sims aqu√≠) üáÆüá±
  "973",  // Bar√©in üáßüá≠
  "974",  // Catar üá∂üá¶
  "975",  // But√°n (no √°rabe, pero spamean desde ah√≠)
  "976",  // Mongolia (se infiltran bots desde aqu√≠)
  "980",  // Temporal / bots √°rabes
  "992",  // Tayikist√°n (usuarios √°rabes isl√°micos)
  "998"   // Uzbekist√°n (tambi√©n isl√°mico)
];
      if (update.action === "add") {
        // Obtener metadata del grupo para verificar administradores
        let groupMetadata = {};
        try {
          groupMetadata = await sock.groupMetadata(update.id);
        } catch (err) {
          console.error("Error obteniendo metadata del grupo:", err);
        }
        for (const participant of update.participants) {
          // Extraer el n√∫mero (la parte antes de "@")
          const phoneNumber = participant.split("@")[0];
          // Comprobar si el n√∫mero comienza con alguno de los prefijos prohibidos
          const isDisallowed = disallowedPrefixes.some(prefix => phoneNumber.startsWith(prefix));
          if (isDisallowed) {
            // Verificar si el usuario es admin o propietario
            let bypass = false;
            const participantInfo = groupMetadata.participants.find(p => p.id === participant);
            if (participantInfo && (participantInfo.admin === "admin" || participantInfo.admin === "superadmin")) {
              bypass = true;
            }
            if (!bypass && !isOwner(participant)) {
              // Enviar aviso mencionando al usuario
              await sock.sendMessage(update.id, {
                text: `‚ö†Ô∏è @${phoneNumber} tiene un n√∫mero prohibido y ser√° expulsado.`,
                mentions: [participant]
              });
              // Intentar expulsar al usuario
              try {
                await sock.groupParticipantsUpdate(update.id, [participant], "remove");
              } catch (expulsionError) {
                console.error("Error al expulsar al usuario:", expulsionError);
              }
            }
          }
        }
      }
    }
    // **************** FIN L√ìGICA ANTIARABE ****************

// **************** L√ìGICA BIENVENIDA/DESPEDIDA ****************
const welcomeActivo = activos.welcome?.[update.id];
const despedidasActivo = activos.despedidas?.[update.id];

if (!welcomeActivo && !despedidasActivo) return;

const welcomePath = "./welcome.json";
let customWelcomes = {};
if (fs.existsSync(welcomePath)) {
  customWelcomes = JSON.parse(fs.readFileSync(welcomePath, "utf-8"));
}

// Textos integrados para bienvenida y despedida
const welcomeTexts = [
  "¬°Bienvenido(a)! Azura Ultra 2.0 Bot te recibe con los brazos abiertos ü§ó‚ú®. ¬°Disfruta y comparte!",
  "¬°Hola! Azura Ultra 2.0 Bot te abraza con alegr√≠a üéâü§ñ. ¬°Prep√°rate para grandes aventuras!",
  "¬°Saludos! Azura Ultra 2.0 Bot te da la bienvenida para que descubras ideas brillantes üöÄüåü.",
  "¬°Bienvenido(a) al grupo! Azura Ultra 2.0 Bot te invita a explorar un mundo de posibilidades ü§©üí°.",
  "¬°Qu√© alegr√≠a verte! Azura Ultra 2.0 Bot te recibe y te hace sentir en casa üè†üíñ.",
  "¬°Hola! Gracias por unirte; Azura Ultra 2.0 Bot te saluda con entusiasmo üéäüòä.",
  "¬°Bienvenido(a)! Cada nuevo miembro es una chispa de inspiraci√≥n en Azura Ultra 2.0 Bot üî•‚ú®.",
  "¬°Saludos cordiales! Azura Ultra 2.0 Bot te env√≠a un abrazo virtual ü§óüíô.",
  "¬°Bienvenido(a)! √önete a la experiencia Azura Ultra 2.0 Bot y comparte grandes ideas üéâüåà.",
  "¬°Hola! Azura Ultra 2.0 Bot te da la bienvenida para vivir experiencias inolvidables üöÄ‚ú®!"
];
const farewellTexts = [
  "¬°Adi√≥s! Azura Ultra 2.0 Bot te despide con gratitud y te desea √©xitos en tus nuevos caminos üëãüí´.",
  "Hasta pronto, desde Azura Ultra 2.0 Bot te deseamos lo mejor y esperamos verte de nuevo üåüüôè.",
  "¬°Chao! Azura Ultra 2.0 Bot se despide, pero siempre tendr√°s un lugar si decides regresar ü§óüíî.",
  "Nos despedimos con cari√±o; gracias por compartir momentos en Azura Ultra 2.0 Bot üè†‚ù§Ô∏è.",
  "¬°Adi√≥s, amigo(a)! Azura Ultra 2.0 Bot te manda un abrazo y te desea mucha suerte ü§ùüåü.",
  "Hasta luego, y gracias por haber sido parte de nuestra comunidad üöÄüíô.",
  "Chao, que tus futuros proyectos sean tan brillantes como t√∫ üåü‚ú®. Azura Ultra 2.0 Bot te recuerda siempre.",
  "¬°Nos vemos! Azura Ultra 2.0 Bot te dice adi√≥s con un coraz√≥n lleno de gratitud ü§ó‚ù§Ô∏è.",
  "¬°Adi√≥s! Que tu camino est√© lleno de √©xitos, te lo desea Azura Ultra 2.0 Bot üöÄüåü.",
  "Hasta pronto, y gracias por haber compartido momentos inolvidables con Azura Ultra 2.0 Bot üëãüíñ."
];

// Procesar seg√∫n la acci√≥n: "add" (entrada) o "remove" (salida)

if (update.action === "add" && welcomeActivo) {
  for (const participant of update.participants) {
    const mention = `@${participant.split("@")[0]}`;
    const customMessage = customWelcomes[update.id];

    if (customMessage) {
      await sock.sendMessage(update.id, {
        text: `üëã| Hola ${mention}!\n\n${customMessage}`,
        mentions: [participant]
      });
    } else {
      const mensajeTexto = welcomeTexts[Math.floor(Math.random() * welcomeTexts.length)];
      let groupDesc = "";
      try {
        const metadata = await sock.groupMetadata(update.id);
        groupDesc = metadata.desc ? `\n\nüìú *Descripci√≥n del grupo:*\n${metadata.desc}` : "";
      } catch (err) {
        groupDesc = "";
      }

      await sock.sendMessage(update.id, {
        text: `üëã ${mention}\n\n${mensajeTexto}${groupDesc}`,
        mentions: [participant]
      });
    }
  }
} else if (update.action === "remove" && despedidasActivo) {
  for (const participant of update.participants) {
    const mention = `@${participant.split("@")[0]}`;
    const mensajeTexto = farewellTexts[Math.floor(Math.random() * farewellTexts.length)];

    await sock.sendMessage(update.id, {
      text: `üëã ${mention}\n\n${mensajeTexto}`,
      mentions: [participant]
    });
  }
}
// **************** FIN L√ìGICA BIENVENIDA/DESPEDIDA ****************

  } catch (error) {
    console.error("Error en el evento group-participants.update:", error);
  }
});
           
            // üü¢ Consola de mensajes entrantes con dise√±o

sock.ev.on("messages.upsert", async (messageUpsert) => {
  try {
    const msg = messageUpsert.messages[0];
    if (!msg) return;
    
    const chatId = msg.key.remoteJid;
    const isGroup = chatId.endsWith("@g.us");
    const sender = msg.key.participant
      ? msg.key.participant.replace(/[^0-9]/g, "")
      : msg.key.remoteJid.replace(/[^0-9]/g, "");
    const botNumber = sock.user.id.split(":")[0];
    const fromMe = msg.key.fromMe || sender === botNumber;
    let messageText = msg.message?.conversation || msg.message?.extendedTextMessage?.text || "";
    let messageType = Object.keys(msg.message || {})[0];
    
    const activos = fs.existsSync("./activos.json") ? JSON.parse(fs.readFileSync("./activos.json")) : {};
    const lista = fs.existsSync("./lista.json") ? JSON.parse(fs.readFileSync("./lista.json")) : [];
    const isAllowedUser = (num) => lista.includes(num);

    console.log(chalk.yellow(`\nüì© Nuevo mensaje recibido`));
    console.log(chalk.green(`üì® De: ${fromMe ? "[T√∫]" : "[Usuario]"} ${chalk.bold(sender)}`));
    console.log(chalk.cyan(`üí¨ Tipo: ${messageType}`));
    console.log(chalk.cyan(`üí¨ Mensaje: ${chalk.bold(messageText || "üìÇ (Mensaje multimedia)")}`));
    console.log(chalk.gray("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"));

// üîó Antilink en grupos
      if (isGroup && activos.antilink?.[chatId]) {
        if (messageText.includes("https://chat.whatsapp.com/")) {
          let canBypass = fromMe || isOwner(sender);
          try {
            const metadata = await sock.groupMetadata(chatId);
            const participant = metadata.participants.find(p => p.id.replace(/[^0-9]/g, "") === sender);
            const isAdmin = participant?.admin === "admin" || participant?.admin === "superadmin";
            if (isAdmin) canBypass = true;
          } catch (e) {
            console.error("Error leyendo metadata (antilink):", e);
            canBypass = true; // Evita expulsar por error si no se puede obtener metadata
          }

          if (!canBypass) {
            await sock.sendMessage(chatId, { delete: msg.key });
            await sock.sendMessage(chatId, {
              text: `‚ö†Ô∏è @${sender} ha enviado un enlace no permitido y ha sido expulsado.`,
              mentions: [msg.key.participant || msg.key.remoteJid]
            });
            try {
              await sock.groupParticipantsUpdate(chatId, [msg.key.participant || msg.key.remoteJid], "remove");
            } catch (e) {
              console.error("Error al expulsar:", e);
            }
            return;
          }
        }
      } 
  //fin de antilink por grupo    
// === INICIO L√ìGICA ANTIPRIVADO ===
try {
  const chatId = msg.key.remoteJid;
  const senderId = msg.key.participant || msg.key.remoteJid;
  const isGroup = chatId.endsWith("@g.us");
  const isFromMe = msg.key.fromMe;

  const senderClean = senderId.replace(/[^0-9]/g, "");
  const botNumber = sock.user.id.split(":")[0];
  const isOwner = global.owner.some(([id]) => id === senderClean);

  const activosPath = "./activos.json";
  const activos = fs.existsSync(activosPath)
    ? JSON.parse(fs.readFileSync(activosPath, "utf-8"))
    : {};

  // ‚úÖ Solo bloquear si:
  // - no es grupo
  // - no es owner
  // - no es el propio bot (fromMe = false)
  if (!isGroup && activos.antiprivado && !isOwner && !isFromMe) {
    await sock.updateBlockStatus(senderId, "block");

    await sock.sendMessage("15167096032@s.whatsapp.net", {
      text: `üö´ Se bloque√≥ autom√°ticamente a: wa.me/${senderClean} por escribir en privado al bot.`
    });

    return;
  }
} catch (e) {
  console.error("‚ùå Error en l√≥gica antiprivado:", e);
}
// === FIN L√ìGICA ANTIPRIVADO ===
// === INICIO L√ìGICA ANTIS STICKERS (15s, 3 strikes, sin notificaci√≥n de desbloqueo) ===
const stickerMsg = msg.message?.stickerMessage || msg.message?.ephemeralMessage?.message?.stickerMessage;

if (isGroup && activos.antis?.[chatId] && !fromMe && stickerMsg) {
  const user = msg.key.participant || msg.key.remoteJid;
  const now = Date.now();

  if (!global.antisSpam) global.antisSpam = {};
  if (!global.antisSpam[chatId]) global.antisSpam[chatId] = {};
  if (!global.antisBlackList) global.antisBlackList = {};

  const userData = global.antisSpam[chatId][user] || {
    count: 0,
    last: now,
    warned: false,
    strikes: 0
  };

  const timePassed = now - userData.last;

  // Reiniciar si pasaron m√°s de 15 segundos
  if (timePassed > 15000) {
    userData.count = 1;
    userData.last = now;
    userData.warned = false;
    userData.strikes = 0;

    // Limpiar de lista negra si estaba
    if (global.antisBlackList[chatId]?.includes(user)) {
      global.antisBlackList[chatId] = global.antisBlackList[chatId].filter(u => u !== user);
    }

  } else {
    userData.count++;
    userData.last = now;
  }

  global.antisSpam[chatId][user] = userData;

  // Al 5¬∞ sticker => advertencia
  if (userData.count === 5) {
    await sock.sendMessage(chatId, {
      text: `‚ö†Ô∏è @${user.split("@")[0]} has enviado 5 stickers. Debes esperar *15 segundos* o si env√≠as *3 stickers m√°s*, ser√°s eliminado autom√°ticamente.`,
      mentions: [user]
    });
    userData.warned = true;
    userData.strikes = 0;
    global.antisSpam[chatId][user] = userData;
  }

  // Si se pasa de 5 y a√∫n no respet√≥ los 15s => eliminar y sumar strike
  if (userData.count > 5 && timePassed < 15000) {
    if (!global.antisBlackList[chatId]) global.antisBlackList[chatId] = [];
    if (!global.antisBlackList[chatId].includes(user)) {
      global.antisBlackList[chatId].push(user);
    }

    await sock.sendMessage(chatId, {
      delete: {
        remoteJid: chatId,
        fromMe: false,
        id: msg.key.id,
        participant: user
      }
    });

    userData.strikes++;
    global.antisSpam[chatId][user] = userData;

    if (userData.strikes >= 3) {
      await sock.sendMessage(chatId, {
        text: `‚ùå @${user.split("@")[0]} fue eliminado por ignorar las advertencias y abusar de los stickers.`,
        mentions: [user]
      });
      await sock.groupParticipantsUpdate(chatId, [user], "remove");
      delete global.antisSpam[chatId][user];
    }
  }
}
// === FIN L√ìGICA ANTIS STICKERS ===
    
// === INICIO GUARDADO ANTIDELETE ===
try {
  const activos = fs.existsSync('./activos.json')
    ? JSON.parse(fs.readFileSync('./activos.json', 'utf-8'))
    : {};
  const activos2 = fs.existsSync('./activos2.json')
    ? JSON.parse(fs.readFileSync('./activos2.json', 'utf-8'))
    : {};
  const isGroup = chatId.endsWith('@g.us');
  const isAntideleteGroup = activos.antidelete?.[chatId] === true;
  const isAntideletePriv = activos2.antideletepri === true;
  const filePath = isGroup ? './antidelete.json' : './antideletepri.json';

  if ((isGroup && isAntideleteGroup) || (!isGroup && isAntideletePriv)) {
    if (!fs.existsSync(filePath)) {
      fs.writeFileSync(filePath, JSON.stringify({}, null, 2));
    }

    const type = Object.keys(msg.message || {})[0];
    const content = msg.message[type];
    const idMsg = msg.key.id;

    // CAMBIO: Detectar correctamente el senderId incluso en privado
    const botNumber = sock.user.id.split(":")[0] + "@s.whatsapp.net";
    const senderId = msg.key.participant || (msg.key.fromMe ? botNumber : msg.key.remoteJid);

    // Si es multimedia y supera 10¬†MB, no guardamos NADA
    if (
      ['imageMessage','videoMessage','audioMessage','documentMessage','stickerMessage'].includes(type) &&
      content.fileLength > 10 * 1024 * 1024
    ) {
      return; // Sale sin guardar
    }

    const guardado = {
      chatId,
      sender: senderId,
      type,
      timestamp: Date.now()
    };

    const saveBase64 = async (mediaType, data) => {
      const stream = await downloadContentFromMessage(data, mediaType);
      let buffer = Buffer.alloc(0);
      for await (const chunk of stream) {
        buffer = Buffer.concat([buffer, chunk]);
      }
      guardado.media = buffer.toString("base64");
      guardado.mimetype = data.mimetype;
    };

    if (msg.message?.viewOnceMessageV2) {
      const inner = msg.message.viewOnceMessageV2.message;
      const viewType = Object.keys(inner)[0];
      const viewData = inner[viewType];
      const mediaType = viewType.replace("Message", "");
      guardado.type = viewType;
      await saveBase64(mediaType, viewData);

    } else if (['imageMessage','videoMessage','audioMessage','documentMessage','stickerMessage'].includes(type)) {
      const mediaType = type.replace('Message', '');
      await saveBase64(mediaType, content);

    } else if (type === 'conversation' || type === 'extendedTextMessage') {
      guardado.text = msg.message.conversation || msg.message.extendedTextMessage?.text || '';
    }

    const data = JSON.parse(fs.readFileSync(filePath, 'utf-8'));
    data[idMsg] = guardado;
    fs.writeFileSync(filePath, JSON.stringify(data, null, 2));
  }
} catch (e) {
  console.error("‚ùå Error al guardar mensaje antidelete:", e);
}
// === FIN GUARDADO ANTIDELETE ===
// === INICIO DETECCI√ìN DE MENSAJE ELIMINADO ===
if (msg.message?.protocolMessage?.type === 0) {
  try {
    const deletedId = msg.message.protocolMessage.key.id;
    const whoDeleted = msg.message.protocolMessage.key.participant || msg.key.participant || msg.key.remoteJid;
    const isGroup = chatId.endsWith('@g.us');

    const activos = fs.existsSync('./activos.json') ? JSON.parse(fs.readFileSync('./activos.json', 'utf-8')) : {};
    const activos2 = fs.existsSync('./activos2.json') ? JSON.parse(fs.readFileSync('./activos2.json', 'utf-8')) : {};
    const isAntideleteGroup = activos.antidelete?.[chatId] === true;
    const isAntideletePriv = activos2.antideletepri === true;
    const filePath = isGroup ? './antidelete.json' : './antideletepri.json';

    if (!(isGroup ? isAntideleteGroup : isAntideletePriv)) return;
    if (!fs.existsSync(filePath)) return;

    const data = JSON.parse(fs.readFileSync(filePath));
    const deletedData = data[deletedId];
    if (!deletedData) return;

    const senderClean = (deletedData.sender || '').replace(/[^0-9]/g, '');
    const whoDeletedClean = (whoDeleted || '').replace(/[^0-9]/g, '');
    if (senderClean !== whoDeletedClean) return;

    const senderNumber = whoDeletedClean;

    if (isGroup) {
      const meta = await sock.groupMetadata(chatId);
      const isAdmin = meta.participants.find(p => p.id === `${senderNumber}@s.whatsapp.net`)?.admin;
      if (isAdmin) return;
    }

    if (deletedData.media) {
      const mimetype = deletedData.mimetype || 'application/octet-stream';
      const buffer = Buffer.from(deletedData.media, "base64");
      const type = deletedData.type.replace("Message", "");
      const sendOpts = { quoted: msg };

      sendOpts[type] = buffer;
      sendOpts.mimetype = mimetype;

      const mentionTag = [`${senderNumber}@s.whatsapp.net`];

      if (type === "sticker") {
        const sent = await sock.sendMessage(chatId, sendOpts);
        await sock.sendMessage(chatId, {
          text: `üìå El sticker fue eliminado por @${senderNumber}`,
          mentions: mentionTag,
          quoted: sent
        });
      } else if (type === "audio") {
        const sent = await sock.sendMessage(chatId, sendOpts);
        await sock.sendMessage(chatId, {
          text: `üéß El audio fue eliminado por @${senderNumber}`,
          mentions: mentionTag,
          quoted: sent
        });
      } else {
        sendOpts.caption = `üì¶ Mensaje eliminado por @${senderNumber}`;
        sendOpts.mentions = mentionTag;
        await sock.sendMessage(chatId, sendOpts, { quoted: msg });
      }
    } else if (deletedData.text) {
      await sock.sendMessage(chatId, {
        text: `üìù *Mensaje eliminado:* ${deletedData.text}\nüë§ *Usuario:* @${senderNumber}`,
        mentions: [`${senderNumber}@s.whatsapp.net`]
      }, { quoted: msg });
    }
  } catch (err) {
    console.error("‚ùå Error en l√≥gica antidelete:", err);
  }
}
// === FIN DETECCI√ìN DE MENSAJE ELIMINADO ===    
    

// === INICIO L√ìGICA CHATGPT POR GRUPO ===
try {
  const activos = fs.existsSync("./activos.json") ? JSON.parse(fs.readFileSync("./activos.json", "utf-8")) : {};
  const isGroup = msg.key.remoteJid.endsWith("@g.us");
  const chatId = msg.key.remoteJid;
  const chatgptActivo = activos.chatgpt?.[chatId];
  const fromMe = msg.key.fromMe;

  const messageText = msg.message?.conversation || 
                      msg.message?.extendedTextMessage?.text || 
                      msg.message?.imageMessage?.caption || 
                      msg.message?.videoMessage?.caption || "";

  if (isGroup && chatgptActivo && !fromMe && messageText.length > 0) {
    const encodedText = encodeURIComponent(messageText);
    const sessionID = "1727468410446638"; // ID de sesi√≥n
    const apiUrl = `https://api.neoxr.eu/api/gpt4-session?q=${encodedText}&session=${sessionID}&apikey=russellxz`;

    const axios = require("axios");
    const res = await axios.get(apiUrl);
    const respuesta = res.data?.data?.message;

    if (respuesta) {
      await sock.sendMessage(chatId, {
        text: respuesta,
      }, { quoted: msg }); // <-- Aqu√≠ se cita correctamente el mensaje del usuario
    }
  }
} catch (e) {
  console.error("‚ùå Error en l√≥gica ChatGPT por grupo:", e);
}
// === FIN L√ìGICA CHATGPT POR GRUPO ===

// === INICIO L√ìGICA LUMI AI POR GRUPO ===
try {
  const activos = fs.existsSync("./activos.json") ? JSON.parse(fs.readFileSync("./activos.json", "utf-8")) : {};
  const isGroup = msg.key.remoteJid.endsWith("@g.us");
  const chatId = msg.key.remoteJid;
  const lumiActivo = activos.lumi?.[chatId];
  const fromMe = msg.key.fromMe;

  const text =
    msg.message?.conversation ||
    msg.message?.extendedTextMessage?.text ||
    msg.message?.imageMessage?.caption ||
    msg.message?.videoMessage?.caption ||
    "";

  if (isGroup && lumiActivo && !fromMe && text.length > 0) {
    const name = '[XEX]';
    const prompt = await getPrompt();
    let result = '';

    try {
      result = await luminaiQuery(text, name, prompt);
      result = cleanResponse(result);
    } catch (e) {
      console.error('Error Luminai:', e);
      try {
        result = await perplexityQuery(text, prompt);
      } catch (e) {
        console.error('Error Perplexity:', e);
        result = '‚ùå No se obtuvo respuesta de los servicios';
      }
    }

    if (result) {
      await sock.sendMessage(chatId, {
        text: result
      }, { quoted: msg });
    }
  }
} catch (error) {
  console.error("‚ùå Error en l√≥gica Lumi AI autom√°tica:", error);
}
// === FIN L√ìGICA LUMI AI POR GRUPO ===
    
// === INICIO CONTADOR DE MENSAJES POR GRUPO ===
try {
  const fs = require("fs");
  const path = require("path");

  const conteoPath = path.resolve("./conteo.json");
  if (!fs.existsSync(conteoPath)) {
    fs.writeFileSync(conteoPath, JSON.stringify({}, null, 2));
  }

  const conteoData = JSON.parse(fs.readFileSync(conteoPath, "utf-8"));

  const chatId = msg.key.remoteJid;
  const senderId = msg.key.participant || msg.key.remoteJid;
  const isGroup = chatId.endsWith("@g.us");
  const fromMe = msg.key.fromMe;
  const botNumber = sock.user.id.split(":")[0] + "@s.whatsapp.net"; // N√∫mero del bot en formato JID

  if (isGroup) {
    // Si mensaje de usuario (no bot)
    if (!fromMe) {
      if (!conteoData[chatId]) conteoData[chatId] = {};
      if (!conteoData[chatId][senderId]) conteoData[chatId][senderId] = 0;
      conteoData[chatId][senderId] += 1;
    }

    // Si mensaje del propio bot
    if (fromMe) {
      if (!conteoData[chatId]) conteoData[chatId] = {};
      if (!conteoData[chatId][botNumber]) conteoData[chatId][botNumber] = 0;
      conteoData[chatId][botNumber] += 1;
    }

    fs.writeFileSync(conteoPath, JSON.stringify(conteoData, null, 2));
  }

} catch (error) {
  console.error("‚ùå Error en contador de mensajes:", error);
}
// === FIN CONTADOR DE MENSAJES POR GRUPO ===
// === INICIO L√ìGICA COMANDOS DESDE STICKER ===
try {
  const jsonPath = "./comandos.json";
  if (!fs.existsSync(jsonPath)) return;

  if (msg.message?.stickerMessage) {
    const fileSha = msg.message.stickerMessage.fileSha256?.toString("base64");
    const comandosData = JSON.parse(fs.readFileSync(jsonPath, "utf-8"));

    const cmd = comandosData[fileSha];
    if (!cmd) return;

    const messageText = cmd.toLowerCase().trim();
    const parts = messageText.split(" ");
    const mainCommand = parts[0];
    const args = parts.slice(1);

    const chatId = msg.key.remoteJid;
    const sender = msg.key.participant || msg.key.remoteJid;

    // Obtener informaci√≥n del mensaje citado (si hay)
    const contextInfo = msg.message?.stickerMessage?.contextInfo || {};
    const quotedMsg = contextInfo.quotedMessage || null;
    const quotedParticipant = contextInfo.participant || null;

    const fakeMessage = {
      ...msg,
      message: {
        extendedTextMessage: {
          text: messageText,
          contextInfo: {
            quotedMessage: quotedMsg,
            participant: quotedParticipant,
            stanzaId: contextInfo.stanzaId || "",
            remoteJid: contextInfo.remoteJid || chatId
          }
        }
      },
      body: messageText,
      text: messageText,
      command: mainCommand,
      key: {
        ...msg.key,
        fromMe: false,
        participant: sender
      }
    };

    const { handleCommand } = require("./main");
    const isPluginCommand = global.plugins?.some(p => p.command?.includes?.(mainCommand));

    // Ejecutar desde main.js (case)
    await handleCommand(sock, fakeMessage, mainCommand, args, sender);

    // Ejecutar si es plugin
    if (isPluginCommand) {
      for (const plugin of global.plugins) {
        if (plugin.command?.includes(mainCommand)) {
          if (typeof plugin.run === "function") {
            await plugin.run({
              msg: fakeMessage,
              conn: sock,
              args,
              command: mainCommand
            });
            break;
          }
        }
      }
    }
  }
} catch (err) {
  console.error("‚ùå Error al ejecutar comando desde sticker:", err);
}
// === FIN L√ìGICA COMANDOS DESDE STICKER ===       
// === L√ìGICA DE RESPUESTA AUTOM√ÅTICA CON PALABRA CLAVE ===
try {
  /* 1Ô∏è‚É£  ‚ÄúmodoAdmins‚Äù YA NO bloquea la respuesta:
         solo lo consultamos por si m√°s adelante quieres usarlo.        */
  const actPath = path.resolve('./activos.json');
  const modoAdminsOn =
    isGroup &&
    fs.existsSync(actPath) &&
    (JSON.parse(fs.readFileSync(actPath, 'utf-8')).modoAdmins?.[chatId] === true);

  /* 2Ô∏è‚É£  Procesar guar.json */
  const guarPath = path.resolve('./guar.json');
  if (fs.existsSync(guarPath)) {
    const guarData  = JSON.parse(fs.readFileSync(guarPath, 'utf-8'));
    const cleanText = messageText
      .toLowerCase()
      .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
      .replace(/[^\w]/g, '');

    for (const key of Object.keys(guarData)) {
      const cleanKey = key
        .toLowerCase()
        .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
        .replace(/[^\w]/g, '');

      if (cleanText === cleanKey) {
        const item   = guarData[key];
        const buffer = Buffer.from(item.buffer, 'base64');
        const payload = {};

        switch (item.extension) {
          case 'jpg':
          case 'jpeg':
          case 'png':  payload.image  = buffer; break;
          case 'mp4':  payload.video  = buffer; break;
          case 'mp3':
          case 'ogg':
          case 'opus': payload.audio    = buffer;
                       payload.mimetype = item.mimetype || 'audio/mpeg';
                       payload.ptt      = false;                break;
          case 'webp': payload.sticker = buffer; break;
          default:     payload.document = buffer;
                       payload.mimetype = item.mimetype || 'application/octet-stream';
                       payload.fileName = `archivo.${item.extension}`;
                       break;
        }

        await sock.sendMessage(chatId, payload, { quoted: msg });
        return;   // coincidencia encontrada
      }
    }
  }
} catch (e) {
  console.error("‚ùå Error en l√≥gica de palabra clave:", e);
}
// === FIN L√ìGICA DE RESPUESTA AUTOM√ÅTICA CON PALABRA CLAVE ===
    
// === INICIO BLOQUEO DE MENSAJES DE USUARIOS MUTEADOS ===
try {
  const chatId = msg.key.remoteJid;
  const isGroup = chatId.endsWith("@g.us");

  if (isGroup) {
    const senderId = msg.key.participant || msg.key.remoteJid;
    const mutePath = "./mute.json";
    const muteData = fs.existsSync(mutePath) ? JSON.parse(fs.readFileSync(mutePath)) : {};
    const muteList = muteData[chatId] || [];

    if (muteList.includes(senderId)) {
      global._muteCounter = global._muteCounter || {};
      const key = `${chatId}:${senderId}`;
      global._muteCounter[key] = (global._muteCounter[key] || 0) + 1;

      const count = global._muteCounter[key];

      if (count === 8) {
        await sock.sendMessage(chatId, {
          text: `‚ö†Ô∏è @${senderId.split("@")[0]} est√°s muteado.\nSigue enviando mensajes y podr√≠as ser eliminado.`,
          mentions: [senderId]
        });
      }

      if (count === 13) {
        await sock.sendMessage(chatId, {
          text: `‚õî @${senderId.split("@")[0]} est√°s al l√≠mite.\nSi env√≠as *otro mensaje*, ser√°s eliminado del grupo.`,
          mentions: [senderId]
        });
      }

      if (count >= 15) {
        const metadata = await sock.groupMetadata(chatId);
        const user = metadata.participants.find(p => p.id === senderId);
        const isAdmin = user?.admin === 'admin' || user?.admin === 'superadmin';

        if (!isAdmin) {
          await sock.groupParticipantsUpdate(chatId, [senderId], "remove");
          await sock.sendMessage(chatId, {
            text: `‚ùå @${senderId.split("@")[0]} fue eliminado por ignorar el mute.`,
            mentions: [senderId]
          });
          delete global._muteCounter[key];
        } else {
          await sock.sendMessage(chatId, {
            text: `üîá @${senderId.split("@")[0]} es administrador y no se puede eliminar.`,
            mentions: [senderId]
          });
        }
      }

      // eliminar mensaje
      await sock.sendMessage(chatId, {
        delete: {
          remoteJid: chatId,
          fromMe: false,
          id: msg.key.id,
          participant: senderId
        }
      });

      return; // este return es interno, no afecta el resto
    }
  }
} catch (err) {
  console.error("‚ùå Error en l√≥gica de muteo:", err);
}
// === FIN BLOQUEO DE MENSAJES DE USUARIOS MUTEADOS ===
// === INICIO BLOQUEO DE COMANDOS A USUARIOS BANEADOS ===
try {
  const banPath = path.resolve("./ban.json");
  const banData = fs.existsSync(banPath) ? JSON.parse(fs.readFileSync(banPath)) : {};

  const messageText = msg.message?.conversation || msg.message?.extendedTextMessage?.text || "";
  if (!messageText.startsWith(global.prefix)) return;

  const commandOnly = messageText.slice(global.prefix.length).trim().split(" ")[0].toLowerCase();

  const senderId = msg.key.participant || msg.key.remoteJid;
  const senderClean = senderId.replace(/[^0-9]/g, "");
  const senderLID = senderId; // ejemplo: 123456789012345@lid
  const senderClassic = `${senderClean}@s.whatsapp.net`; // ejemplo: 521234567890@...

  const isFromMe = msg.key.fromMe;
  const isOwner = global.owner.some(([id]) => id === senderClean);

  const groupBanList = banData[chatId] || [];

  if ((groupBanList.includes(senderClassic) || groupBanList.includes(senderLID)) && !isOwner && !isFromMe) {
    const frases = [
      "üö´ @usuario est√°s baneado por pendejo. ¬°Abusaste demasiado del bot!",
      "‚ùå Lo siento @usuario, pero t√∫ ya no puedes usarme. Aprende a comportarte.",
      "üîí No tienes permiso @usuario. Fuiste baneado por molestar mucho.",
      "üëé ¬°Bloqueado! @usuario abusaste del sistema y ahora no puedes usarme.",
      "üò§ Quisiste usarme pero est√°s baneado, @usuario. Vuelve en otra vida."
    ];

    const texto = frases[Math.floor(Math.random() * frases.length)].replace("@usuario", `@${senderClean}`);

    await sock.sendMessage(chatId, {
      text: texto,
      mentions: [senderId]
    }, { quoted: msg });

    return;
  }
} catch (e) {
  console.error("‚ùå Error procesando bloqueo de usuarios baneados:", e);
}
// === FIN BLOQUEO DE COMANDOS A USUARIOS BANEADOS ===    
// === INICIO BLOQUEO AUTOM√ÅTICO DE N√öMEROS √ÅRABES EN PRIVADO ===
try {
  const chatId = msg.key.remoteJid;
  const isGroup = chatId.endsWith("@g.us");

  if (!isGroup) {
    const sender = msg.key.participant || msg.key.remoteJid;
    const senderNum = sender.replace(/[^0-9]/g, "");

    // Lista de prefijos telef√≥nicos √°rabes
    const disallowedPrefixes = [
      "20", "212", "213", "216", "218", "222", "249", "252",
      "253", "269", "962", "963", "964", "965", "966", "967",
      "968", "970", "971", "972", "973", "974", "975", "976",
      "977", "980", "981", "982", "983", "984", "985", "986", "987", "988", "989"
    ];

    const esArabe = disallowedPrefixes.some(pref => senderNum.startsWith(pref));

    if (esArabe) {
      // Bloquear al √°rabe
      await sock.updateBlockStatus(sender, "block");

      // Obtener el n√∫mero del propio bot
      const myJid = sock.user.id.split(":")[0] + "@s.whatsapp.net";

      // Notificar al bot mismo
      await sock.sendMessage(myJid, {
        text: `üìõ *N√∫mero √°rabe bloqueado autom√°ticamente:*\n\nüßø N√∫mero: wa.me/${senderNum}\nüì© Intent√≥ escribir al bot en privado.\n\n‚úÖ El n√∫mero fue bloqueado.`
      });

      // Mensaje al √°rabe bloqueado (opcional)
      await sock.sendMessage(sender, {
        text: "üö´ Este bot no acepta mensajes privados de n√∫meros √°rabes. Has sido bloqueado autom√°ticamente."
      });

      return;
    }
  }
} catch (e) {
  console.error("‚ùå Error en bloqueo autom√°tico de √°rabes:", e);
}
// === FIN BLOQUEO AUTOM√ÅTICO DE N√öMEROS √ÅRABES EN PRIVADO ===

    
// üîê Modo Privado activado
    if (activos.modoPrivado) {
      if (isGroup) {
        if (!fromMe && !isOwner(sender)) return;
      } else {
        if (!fromMe && !isOwner(sender) && !isAllowedUser(sender)) return;
      }
    } else {
      // üéØ Modo Admins por grupo
      if (isGroup && activos.modoAdmins?.[chatId]) {
        try {
          const metadata = await sock.groupMetadata(chatId);
          const participant = metadata.participants.find(p => p.id.includes(sender));
          const isAdmin = participant?.admin === "admin" || participant?.admin === "superadmin";
          if (!isAdmin && !isOwner(sender) && !fromMe) return;
        } catch (e) {
          console.error("Error leyendo metadata:", e);
          return;
        }
      }

      

      // üîí En privado si no es de la lista, no responde
      if (!isGroup && !fromMe && !isOwner(sender) && !isAllowedUser(sender)) return;
    }

// === INICIO BLOQUEO DE COMANDOS SI EL BOT EST√Å APAGADO EN EL GRUPO ===
try {
  const activosPath = "./activos.json";
  const activos = fs.existsSync(activosPath)
    ? JSON.parse(fs.readFileSync(activosPath, "utf-8"))
    : {};

  const isApagado = activos.apagado?.[chatId] === true;
  const senderClean = sender.replace(/[^0-9]/g, "");
  const isOwner = global.owner.some(([id]) => id === senderClean);

  if (isGroup && isApagado && !isOwner) {
    return; // Ignora comandos de usuarios comunes si el bot est√° apagado
  }
} catch (e) {
  console.error("‚ùå Error en l√≥gica de bloqueo por apagado:", e);
}
// === FIN BLOQUEO DE COMANDOS SI EL BOT EST√Å APAGADO EN EL GRUPO ===
    
// === INICIO BLOQUEO AUTOM√ÅTICO COMANDOS RPG AZURA ===
try {
  const comandosRpg = [
    "rpg", "nivel", "picar", "minar", "minar2", "work", "crime", "robar", "cofre",
    "claim", "batallauser", "hospital", "hosp", "luchar", "poder", "volar",
    "otromundo", "otrouniverso", "mododios", "mododiablo", "podermaximo",
    "enemigos", "nivelper", "per", "bolasdeldragon", "vender", "quitarventa",
    "batallaanime", "comprar", "tiendaper", "alaventa", "verper", "daragua",
    "darcari√±o", "darcomida", "presumir", "cazar", "entrenar", "pasear",
    "supermascota", "mascota", "curar", "nivelmascota", "batallamascota",
    "compra", "tiendamascotas", "vermascotas", "addmascota", "addper",
    "deleteuser", "deleteper", "deletemascota", "totalper", "tran", "transferir",
    "dame", "dep", "bal", "saldo", "retirar", "depositar", "delrpg", "topuser",
    "topmascotas", "topper"
  ];

  const activosPath = path.resolve("./activos.json");
  const activos = fs.existsSync(activosPath) ? JSON.parse(fs.readFileSync(activosPath)) : {};

  const messageText = msg.message?.conversation || msg.message?.extendedTextMessage?.text || "";

  // NUEVO: Validar prefijo actual
  if (!messageText.startsWith(global.prefix)) return;

  const commandOnly = messageText.slice(global.prefix.length).trim().split(" ")[0].toLowerCase();

  const rpgActivo = activos.rpgazura?.[chatId];

  if (comandosRpg.includes(commandOnly) && !rpgActivo) {
    const mensajesBloqueo = [
      "üö´ Este comando RPG est√° desactivado en este grupo. Usa .rpgazura on o off.",
      "üõë El mundo RPG est√° apagado. Usa .rpgazura on o off.",
      "‚ùå Comandos RPG no disponibles. Usa .rpgazura on o off.",
      "üö∑ Sistema RPG desactivado. Usa .rpgazura on o off."
    ];
    const textoBloqueo = mensajesBloqueo[Math.floor(Math.random() * mensajesBloqueo.length)];

    await sock.sendMessage(chatId, { text: textoBloqueo }, { quoted: msg });
    return;
  }

} catch (e) {
  console.error("‚ùå Error procesando bloqueo de comandos RPG:", e);
}
// === FIN BLOQUEO AUTOM√ÅTICO COMANDOS RPG AZURA ===
// === INICIO BLOQUEO AUTOM√ÅTICO COMANDOS +18 (MODO CALIENTE) ===
try {
  const comandosHot = ["videoxxx", "pornololi", "nsfwneko", "nsfwwaifu", "waifu", "neko", "futanari", "futasolo"];

  const activosPath = path.resolve("./activos.json");
  const activos = fs.existsSync(activosPath) ? JSON.parse(fs.readFileSync(activosPath)) : {};

  const messageText = msg.message?.conversation || msg.message?.extendedTextMessage?.text || "";

  // NUEVO: Validar prefijo actual
  if (!messageText.startsWith(global.prefix)) return;

  const commandOnly = messageText.slice(global.prefix.length).trim().split(" ")[0].toLowerCase();

  const senderClean = sender.replace(/[^0-9]/g, "");
  const isOwner = global.owner.some(([id]) => id === senderClean);
  const isFromMe = msg.key.fromMe;

  const calienteActivo = activos.modocaliente?.[chatId];

  if (comandosHot.includes(commandOnly) && !calienteActivo && !isOwner && !isFromMe) {
    const mensajesBloqueo = [
      "üö´ Velo pajiso, este comando +18 est√° desactivado. P√≠dele a un admin que lo active con .modocaliente on o off.",
      "‚ùå Qu√© desesperaci√≥n, agu√°ntese. El modo caliente no est√° activado con .modocaliente on o off.",
      "üõë Este comando +18 est√° apagado. Primero active el modo caliente con .modocaliente on o off.",
      "üö∑ Caliente frustrado detectado. El modo +18 est√° desactivado en este grupo."
    ];
    const textoBloqueo = mensajesBloqueo[Math.floor(Math.random() * mensajesBloqueo.length)];

    await sock.sendMessage(chatId, { text: textoBloqueo }, { quoted: msg });
    return;
  }

} catch (e) {
  console.error("‚ùå Error procesando bloqueo de modo caliente:", e);
}
// === FIN BLOQUEO AUTOM√ÅTICO COMANDOS +18 ===    
    //restringir comandos
    try {
  const rePath = path.resolve("./re.json");
  const cachePath = path.resolve("./restriccion_cache.json");

  if (!fs.existsSync(cachePath)) fs.writeFileSync(cachePath, JSON.stringify({}, null, 2));

  const reData = fs.existsSync(rePath) ? JSON.parse(fs.readFileSync(rePath)) : {};
  const cacheData = JSON.parse(fs.readFileSync(cachePath));

  const commandOnly = messageText.slice(global.prefix.length).trim().split(" ")[0].toLowerCase();
  const comandosRestringidos = reData[chatId] || [];

  const senderClean = sender.replace(/[^0-9]/g, "");
  const isOwner = global.owner.some(([id]) => id === senderClean);
  const isFromMe = msg.key.fromMe;

  const key = `${chatId}:${senderClean}:${commandOnly}`;

  // Si el comando ya no est√° restringido, eliminarlo del contador
  if (!comandosRestringidos.includes(commandOnly) && cacheData[key]) {
    delete cacheData[key];
    fs.writeFileSync(cachePath, JSON.stringify(cacheData, null, 2));
    return;
  }

  if (comandosRestringidos.includes(commandOnly) && !isOwner && !isFromMe) {
    cacheData[key] = (cacheData[key] || 0) + 1;

    const replyOptions = {
      quoted: msg,
      mentions: [sender + "@s.whatsapp.net"]
    };

    if (cacheData[key] < 5) {
      await sock.sendMessage(chatId, {
        text: `üö´ *Este comando est√° restringido en este grupo.*\n‚ö†Ô∏è Solo el owner o el bot pueden usarlo.`,
      }, replyOptions);
    } else if (cacheData[key] === 5) {
      await sock.sendMessage(chatId, {
        text: `‚ùå *Has intentado usar este comando demasiadas veces.*\nü§ñ Ahora el bot te ignorar√° respecto a *${commandOnly}*.`,
      }, replyOptions);
    }

    fs.writeFileSync(cachePath, JSON.stringify(cacheData, null, 2));
    return;
  }

} catch (e) {
  console.error("‚ùå Error procesando comando restringido:", e);
}
// === FIN L√ìGICA DE COMANDOS RESTRINGIDOS ===    


    // ‚úÖ Procesar comando
    if (messageText.startsWith(global.prefix)) {
      const command = messageText.slice(global.prefix.length).trim().split(" ")[0];
      const args = messageText.slice(global.prefix.length + command.length).trim().split(" ");
      handleCommand(sock, msg, command, args, sender);
    }

  } catch (error) {
    console.error("‚ùå Error en messages.upsert:", error);
  }
});
            
            
            sock.ev.on("connection.update", async (update) => {
    const { connection } = update;

    if (connection === "connecting") {
        console.log(chalk.blue("üîÑ Conectando a WhatsApp..."));
    } else if (connection === "open") {
        console.log(chalk.green("‚úÖ ¬°Conexi√≥n establecida con √©xito!"));
//await joinChannels(sock)

        // üìå Verificar si el bot se reinici√≥ con .rest y enviar mensaje
        const restarterFile = "./lastRestarter.json";
        if (fs.existsSync(restarterFile)) {
            try {
                const data = JSON.parse(fs.readFileSync(restarterFile, "utf-8"));
                if (data.chatId) {
                    await sock.sendMessage(data.chatId, { text: "‚úÖ *El bot est√° en l√≠nea nuevamente tras el reinicio.* üöÄ" });
                    console.log(chalk.green("üì¢ Notificaci√≥n enviada al chat del reinicio."));
                    fs.unlinkSync(restarterFile); // üîÑ Eliminar el archivo despu√©s de enviar el mensaje
                }
            } catch (error) {
                console.error("‚ùå Error al procesar lastRestarter.json:", error);
            }
        }
    } else if (connection === "close") {
        console.log(chalk.red("‚ùå Conexi√≥n cerrada. Intentando reconectar en 5 segundos..."));
        setTimeout(startBot, 5000);
    }
});

const path = require("path");
            
            
            sock.ev.on("creds.update", saveCreds);

            // Manejo de errores global para evitar que el bot se detenga
            process.on("uncaughtException", (err) => {
                console.error(chalk.red("‚ö†Ô∏è Error no manejado:"), err);
            });

            process.on("unhandledRejection", (reason, promise) => {
                console.error(chalk.red("üö® Promesa rechazada sin manejar:"), promise, "raz√≥n:", reason);
            });

        } catch (error) {
            console.error(chalk.red("‚ùå Error en la conexi√≥n:"), error);
            console.log(chalk.blue("üîÑ Reiniciando en 5 segundos..."));
            setTimeout(startBot, 5000); // Intentar reconectar despu√©s de 5 segundos en caso de error
        }
    }

    startBot();

})();
